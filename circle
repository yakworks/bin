#!/bin/bash
# ---
# working with CI circle and publishing,
# should be imported into the main build.sh
# ---
set -e

# ---
# for multi-project gradles this
# cats the props and build.gradle into a single cache-key.tmp file
# so we can so checksum on that one file to see if there are any changes
# if any build files change then it will not get cache and gradle will re-download the internet
# $1 - the project list, if not passed then defaults to whats in env variable GRADLE_PROJECTS
# ---
function create_cache_key {
  cat gradle.properties build.gradle > cache-key.tmp
  local projList="${1:-$GRADLE_PROJECTS}"
  for project in $projList; do
    [ -f $project/build.gradle ] && cat $project/build.gradle >> cache-key.tmp
    [ -f $project/gradle.properties ] && cat $project/gradle.properties >> cache-key.tmp
  done
  return 0 # do this so make doesn't do make: *** [cache_key_file] Error 1
}

# ---
# for multi-project gradles this will consolidate the test results into the root build
# this simplifies so we can run circles "store" command on just one dir
# $1 - the project list, if not passed then defaults to whats in env variable GRADLE_PROJECTS
# ---
function merge_test_results {
  local projList="${1:-$GRADLE_PROJECTS}"
  for project in $projList; do
    _copy_test_results "$project" "test-results"
    _copy_test_results "$project" "reports"
  done
}

# $1 - the project name
# $2 - the build test dir, will either be test-results or reports
function _copy_test_results {
  local dir="$1/build/$2/"
  if [ -d "${dir}" ]; then
    mkdir -p build/$2/$1
    cp -r "$dir" build/$2/$1
  fi
}

# ---
# triggers or invoke a circle pipleline job. the CIRCLE_TOKEN env variable should be setup
# $1 - the repo slug, for example 'yakworks/gorm-tools' to call the build for that one
# --
function trigger-circle {
  curl --location --request POST \
    "https://circleci.com/api/v2/project/github/${1}/pipeline" \
    --header 'Content-Type: application/json' \
    -u "${CIRCLE_TOKEN}:"
}

# does the logic for CI to publish the lib
# $1 - the current branch we are on, on circle pass in $CIRCLE_BRANCH
# !DEPRECATED here for history only
function ci-publish-lib {
  # uncomment these for testing
  # CIRCLE_BRANCH=master
  # CIRCLE_COMMIT_RANGE=911ff1ea1fa5...a883787c2f50

  # Old stuff in case we want to resurect the change detection based on commit range
  # CIRCLE_COMMIT_RANGE=$(circleCommitRange)
  # HAS_APP_CHANGES=$(hasAppChanges "$CIRCLE_COMMIT_RANGE")
  IS_RELEASABLE_BRANCH=$(is_releasable_branch "$1")

  if [[ $IS_RELEASABLE_BRANCH ]]; then
    echo "IS_RELEASABLE_BRANCH:true , snapshot: $snapshot .. calling ./gradlew publish"
    ./gradlew publish
    # if not snapshot then run through the release files of changelog, version bump and git push
    if [ "$snapshot" == "false" ]; then
      releaseFiles $1
    fi
  else
    echo "IS_RELEASABLE_BRANCH:false ... not publishing"
  fi
}

# ---
# circle orb compare-url/reconstruct makes a CIRCLE_COMPARE_URL.txt and this will
# returns the commit range like 911ff1ea1fa5...a883787c2f50
# ---
function circleCommitRange {
  CIRCLE_COMPARE_URL=$(cat CIRCLE_COMPARE_URL.txt || true)
  # echo "CIRCLE_COMPARE_URL $CIRCLE_COMPARE_URL"
  echo "$CIRCLE_COMPARE_URL" | rev | cut -d/ -f1 | rev
}

# --- boiler plate function runner, keep at end of file ------
# BASH_SOURCE check will be true if this is run, false if imported into another script with `source`
if [[ "${#BASH_SOURCE[@]}" == 1 ]]; then
  source "$(dirname $0)/function_runner.sh"
fi
