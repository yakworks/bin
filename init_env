#!/bin/bash
# ---
# default functions to setup BUILD_VARS
# BUILD_VARS are used in the build.sh and a makefile.env is created
# that is imcluded at the start of the Makefile to share vars
# ---
__dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" # get dir this script is in
source "${__dir}/setVar"
source "${__dir}/init_docker_builders"
source "${__dir}/yaml"
source "${__dir}/utils"

# version.properties should be in root dir
if [ -e "version.properties" ]; then source version.properties; fi

# initializes the environment
function init_env {
  [ "$version" ] && init_versions
  # if gradle project then this imports vars from the build.yml
  init_from_build_yml
  # standards
  setVar PROJECT_NAME ${PROJECT_FULLNAME##*/}

  # add pages defaults
  init_pages_defaults
  # if this is running in circle then this will init variables for brnach and releaseing
  circle_init_env
  # build and env vars
  init_docker_builders
  # this is where to put custom stuff in the build.sh
  # post_init_env
}

# sets up defaults vars for docker ninedb and dock builders
function init_from_build_yml {
  # if gradle
  if [ -e ./build.yml ]; then
    create_yml_variables "./build.yml"

    local varsToEval="project_fullName project_subprojects "
    # release
    varsToEval+="release_changelog release_branch_regex "
    # pages
    varsToEval+="pages_build_dir pages_branch "
    # builder
    varsToEval+="builder_exec builder_name builder_url "
    # app
    varsToEval+="app_name app_key app_dir app_jar app_docker_url "
    # k8s
    varsToEval+="app_kub_nfs app_kub_namespace app_kub_ingress_url "

    for varName in $varsToEval; do
      local upperVarName=$(toupper "$varName")
      [ "${!varName}" ] && evalVar $upperVarName "${!varName}"
    done

    # special handling, kubernetes requires all lower case for names so we abide and lower APP_KEY
    [ "$APP_KEY" ] && APP_KEY=$(tolower "$APP_KEY")
    [ "$APP_KUB_INGRESS_URL" ] && APP_KUB_INGRESS_URL=$(tolower "$APP_KUB_INGRESS_URL")

  fi
}


# ---
# sets the version and sets up the other useful variables for that version such as
# VERX_NO_DOTS and the NINEDB_VERSION
# ---
function init_versions {
  # if nothing passing in the usee the lowercase version that should have come in from version.properties
  # local ver=${1:-$version}
  setVar VERSION "$version"
  setVar PUBLISHED_VERSION "$publishedVersion"

  local dotCount=$(echo "${VERSION}" | awk -F"." '{print NF-1}')
  # cuts to the last dot
  local baseVersion=$(echo $VERSION | cut -d. -f1-$dotCount)

  # VERSIONX is used for docker and k8s as we deploy latests minor version
  # also used to connect to the latest compatible database when that is relevant
  setVar VERSIONX "$baseVersion.x"
  #replace dots with - so 10.0.x turns into v10-0-x. k8s can't have dots in names
  setVar VERX_NO_DOTS "v${VERSIONX//./-}"

  setVar BUILD_VERSION "$VERSION"

  # if its a snapshot then append the SNAPSHOT
  if [ $(isTruthy $snapshot) ]; then
    setVar IS_SNAPSHOT true
    BUILD_VERSION+="-SNAPSHOT"
    VERX_NO_DOTS+="-SNAPSHOT"
  fi

  return 0
}

# sets up defaults for PAGESif they are not setup already
function init_pages_defaults {
  setVar PAGES_BUILD_DIR "build/gh-pages"
  setVar PAGES_BRANCH "gh-pages"
}

# sets up defaults vars for docker ninedb and dock builders
function circle_init_env {
  # if CIRCLE_BRANCH is set then consider it setup
  if [ "$CIRCLE_BRANCH" ]; then
    add_build_vars CIRCLE_BRANCH
    setVar RELEASABLE_BRANCH $(is_releasable_branch "$CIRCLE_BRANCH" "$RELEASE_BRANCH_REGEX")
  fi
}

# ---
# checks if the passed in branch matches whats in the release_branch_regex var
# $1 - the branch name
# $2 - the RELEASE_BRANCH_REGEX
# returns the branch name if it matches, empty if not
# ---
function is_releasable_branch {
  # wraps in the ^(..)$ so it only matches full word not partials
  local grepRegex="^(${RELEASE_BRANCH_REGEX})$"
  # returns the branch name if it matches, empty if not
  echo "$1" | grep -E "$grepRegex" || true
}

# create build/make_env_db.env for importing into makefile.
# $1 - BUILD_ENV (test, dev, seed)
# $2 - DBMS Vendor (sqlserver,mysql, etc) *optional*
function make_env_file {
  set_build_env $1 $2
  # init_env
  mkdir -p build/make
  createEnvFile "build/make/makefile.env"
}

# set build environment
# $1 - BUILD_ENV (test, dev, seed)
# $2 - DBMS Vendor (sqlserver,mysql, etc) *optional*
function set_build_env {
  setVar BUILD_ENV ${1:-test}
  [ "$2" ] && setDbEnv $2
  post_build_env
}

# dummy place holder, should be overriden in projects build.sh
function post_build_env { :; }

# create env file from BUILD_VARS for importing into makefile.
# arg $1 - the file to use
function createEnvFile {
  echo "# ----- Generated from build.sh --------" > $1
  for varName in $BUILD_VARS; do
      val=${!varName}
      echo "$varName=$val" >> $1
  done
  echo "BUILD_VARS=$BUILD_VARS" >> $1
  echo "created $1"
}

# parses the env file, eval and load into BUILD_VARS
# $1 - the env file to parse
function parse_env_file {

  local lines=$(cat "$1")
  local line key
	while IFS= read -r line; do
    # trim leading whitespace
		line=${line#"${line%%[![:space:]]*}"}
    # trim trailing whitespace
		line=${line%"${line##*[![:space:]]}"}
    # move on if its a comment
		if [[ ! "$line" || "$line" == '#'* ]]; then continue ; fi
    # echo "line $line"
    key="${line%%=*}"
    val="${line#*=}"
    setVar $key "$val"
	done <<<"$lines"
  # log-vars
}


