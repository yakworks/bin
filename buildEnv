# ---
# functions so setup BUILD_VARS
# BUILD_VARS are used in the build.sh and a makefile.env is created
# that is imcluded at the start of the Makefile to share vars
# ---

# create build/make_env_db.env for importing into makefile.
# $1 - BUILD_ENV (test, dev, seed)
# $2 - DBMS Vendor (sqlserver,mysql, etc)
function makeEnvFile {
  initEnv $1 $2
  mkdir -p build/make
  createEnvFile "build/make/makefile.env"
}

# set build environment
# $1 - BUILD_ENV (test, dev, seed)
# $2 - DBMS Vendor (sqlserver,mysql, etc)
function initEnv {
  setVar BUILD_ENV ${1:-test}
  [ "$2" ] && setDbEnv $2
  # if gradle project then this imports vars from the build.yml
  gradleInit
  # if this is running in circle then this will init variables for brnach and releaseing
  circleInit
  # build and env vars
  setupDockerExecs
  # this is where to put custom stuff in the build.sh
  postInitEnv
}

# dummy place holder, should be overriden in projects build.sh
function postInitEnv { :; }

# sets up defaults vars for docker ninedb and dock builders
function gradleInit {
  # if gradle
  if [ -e ./gradle/build.yml ]; then
    init_from_build_yml "gradle/build.yml"
  fi
}

# sets up defaults vars for docker ninedb and dock builders
function circleInit {
  # setVar GIT_BRANCH "$(current-git-branch)"
  # if CIRCLE_BRANCH is set then consider it setup
  if [ "$CIRCLE_BRANCH" ]; then
    GIT_BRANCH=$CIRCLE_BRANCH
    RELEASABLE_BRANCH=$(isReleasableBranch "$CIRCLE_BRANCH")
    addBuildVars RELEASABLE_BRANCH
    addBuildVars CIRCLE_BRANCH
    addBuildVars GIT_BRANCH
  fi
}

# create env file from BUILD_VARS for importing into makefile.
# arg $1 - the file to use
function createEnvFile {
  echo "# ----- Generated from build.sh --------" > $1
  for varName in $BUILD_VARS; do
      val=${!varName}
      echo "$varName=$val" >> $1
  done
  echo "BUILD_VARS=$BUILD_VARS" >> $1
  echo "created $1"
}

# sets up defaults vars for docker ninedb and dock builders
function setupDockerExecs {
  # default docker builder
  setVar DOCK_BUILDER_NAME "${PROJECT_NAME}-builder"
  setVar DOCK_BUILDER_URL "yakworks/alpine-jdk:builder8"

  # Defaults for builderes
  setVar USE_DOCKER_DB_BUILDER false
  # if /.dockerenv this is inside a docker (such as circleCI) already
  # then we don't want to run docker in dockers, so force to false
  if [ -f /.dockerenv ] || [ "$CI" == "true" ]; then
    USE_DOCKER_DB_BUILDER=false
  fi

  setVar DockerShellExec "docker exec -it ${DOCK_BUILDER_NAME}"
}

# setups the env specific variables
# $1 - the database dbms (mysql,sqlserver,etc)
function setDbEnv {
  # arg $1 must always be the database, defaults to mysql if nothing specified
  setVar DBMS ${1:-mysql}
  setVar DOCK_DB_BUILD_NAME "$DBMS-build"
  : "${NINEDB_VERSION:=$VERSIONX}"
  : "${DOCKER_NINEDB_REPO:=dock9/nine-db}"
  : "${DB_IMAGE_TAG:=${DBMS}-${NINEDB_VERSION}}"
  setVar DOCKER_DB_URL "$DOCKER_NINEDB_REPO:$DB_IMAGE_TAG"

  setVar DB_NAME rcm_9ci_${BUILD_ENV}

  # **** DB Vars (MYSQL by default) ****
  setVar DB_HOST 127.0.0.1
  setVar DB_PORT 3306
  # PASS_VAR_NAME is the environment variable name that the docker dbs require. will be different based on vendor
  setVar PASS_VAR_NAME "MYSQL_ROOT_PASSWORD"

  # DBMS overrides for sqlserver (Oracle in future)
  if [ "$DBMS" == "sqlserver" ]; then
    PASS_VAR_NAME="SA_PASSWORD"
    DB_PORT=1433
  fi
  if [ "$USE_DOCKER_DB_BUILDER" = "true" ]; then
    setVar DockerDbExec "docker exec ${DOCK_DB_BUILD_NAME}"
  fi
  # if we are inside the docker builder but not in circleCI force the DB_HOST
  if [ -f /.dockerenv ] && [ "$CI" != "true" ]; then
    setVar DB_HOST "${DOCK_DB_BUILD_NAME}"
  fi
}

# initialize from build.yml
# arg $1 - the file
function init_from_build_yml {
  create_yml_variables $1
  setVar RELEASABLE_BRANCHES "$git_releasableBranchRegex"
  setVar GITHUB_FULLNAME "$github_fullName"
  setVar CHANGELOG_NAME "$releaseNotes_file"
  # keeps whats after last /
  setVar PROJECT_NAME ${GITHUB_FULLNAME##*/}
}

# just spins through the BUILD_VARS and creates BUILD_VARS_SED_ARGS
# for sed replace in the form s|\${$SOME_VAR}|the value|g;
# after this is called then can be ued like ` sed "$BUILD_VARS_SED_ARGS" someFile.yml > processed.yml `
function buildSedArgs {
  for varName in $BUILD_VARS; do
    ESCAPED_VarName=$(printf '%s\n' "${!varName}" | sed -e 's/[\|&]/\\&/g')
    BUILD_VARS_SED_ARGS+="s|\\\${$varName}|$ESCAPED_VarName|g; "
  done
  # echo "$BUILD_VARS_SED_ARGS"
}

# runs sed on the tpl.yml (kubernetes) template files to update and replace variables with values
# $1 - the tpl.yml file
# $2 - the dir for sed to put the processed file
# echos out the processed tpl build file location
function sedTplYml {
  buildSedArgs
  mkdir -p "$2"
  # parse just the file name
  local tplFile=${1##*/}
  # replace .tpl.yml with .yml is what `/.tpl.yml/.yml` is doing
  local processedTpl="$2/${tplFile/.tpl.yml/.yml}"
  sed "$BUILD_VARS_SED_ARGS" "$1" > "$processedTpl"
	echo "$processedTpl"
}

